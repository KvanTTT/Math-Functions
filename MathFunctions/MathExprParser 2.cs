//Generated by the GOLD Parser Builder

using System.IO;

class MyParser
{
    private GOLD.Parser parser = new GOLD.Parser(); 

    private enum SymbolIndex
    {
        @Eof = 0,                                  // (EOF)
        @Error = 1,                                // (Error)
        @Whitespace = 2,                           // Whitespace
        @Apost = 3,                                // ''
        @Lparan = 4,                               // '('
        @Rparan = 5,                               // ')'
        @Comma = 6,                                // ','
        @Dot = 7,                                  // '.'
        @Semi = 8,                                 // ';'
        @Caret = 9,                                // '^'
        @Pipe = 10,                                // '|'
        @Eq = 11,                                  // '='
        @Addliteral = 12,                          // AddLiteral
        @Id = 13,                                  // Id
        @Multliteral = 14,                         // MultLiteral
        @Number1 = 15,                             // 'Number1'
        @Number2 = 16,                             // 'Number2'
        @Addition = 17,                            // <Addition>
        @Devider = 18,                             // <Devider>
        @Exponentiation = 19,                      // <Exponentiation>
        @Expression = 20,                          // <Expression>
        @Expressionlist = 21,                      // <ExpressionList>
        @Funcdef = 22,                             // <FuncDef>
        @Multiplication = 23,                      // <Multiplication>
        @Negation = 24,                            // <Negation>
        @Statement = 25,                           // <Statement>
        @Statements = 26,                          // <Statements>
        @Value = 27                                // <Value>
    }

    private enum ProductionIndex
    {
        @Statements = 0,                           // <Statements> ::= <Statements> <Devider> <Statement>
        @Statements2 = 1,                          // <Statements> ::= <Statements> <Devider>
        @Statements3 = 2,                          // <Statements> ::= <Statement>
        @Devider_Semi = 3,                         // <Devider> ::= ';'
        @Devider_Dot = 4,                          // <Devider> ::= '.'
        @Statement_Eq = 5,                         // <Statement> ::= <Expression> '=' <Expression>
        @Statement = 6,                            // <Statement> ::= <Expression>
        @Expression = 7,                           // <Expression> ::= <FuncDef>
        @Expression2 = 8,                          // <Expression> ::= <Addition>
        @Funcdef_Id_Lparan_Rparan = 9,             // <FuncDef> ::= Id '(' <ExpressionList> ')'
        @Funcdef_Id_Apost_Lparan_Rparan = 10,      // <FuncDef> ::= Id '' '(' <ExpressionList> ')'
        @Funcdef_Id_Lparan_Rparan_Apost = 11,      // <FuncDef> ::= Id '(' <ExpressionList> ')' ''
        @Expressionlist_Comma = 12,                // <ExpressionList> ::= <ExpressionList> ',' <Expression>
        @Expressionlist = 13,                      // <ExpressionList> ::= <Expression>
        @Addition_Addliteral = 14,                 // <Addition> ::= <Addition> AddLiteral <Multiplication>
        @Addition_Addliteral2 = 15,                // <Addition> ::= <Addition> AddLiteral <FuncDef>
        @Addition_Addliteral3 = 16,                // <Addition> ::= <FuncDef> AddLiteral <Multiplication>
        @Addition_Addliteral4 = 17,                // <Addition> ::= <FuncDef> AddLiteral <FuncDef>
        @Addition = 18,                            // <Addition> ::= <Multiplication>
        @Multiplication_Multliteral = 19,          // <Multiplication> ::= <Multiplication> MultLiteral <Exponentiation>
        @Multiplication_Multliteral2 = 20,         // <Multiplication> ::= <Multiplication> MultLiteral <FuncDef>
        @Multiplication_Multliteral3 = 21,         // <Multiplication> ::= <FuncDef> MultLiteral <Exponentiation>
        @Multiplication_Multliteral4 = 22,         // <Multiplication> ::= <FuncDef> MultLiteral <FuncDef>
        @Multiplication = 23,                      // <Multiplication> ::= <Exponentiation>
        @Exponentiation_Caret = 24,                // <Exponentiation> ::= <Exponentiation> '^' <Negation>
        @Exponentiation_Caret2 = 25,               // <Exponentiation> ::= <Exponentiation> '^' <FuncDef>
        @Exponentiation_Caret3 = 26,               // <Exponentiation> ::= <FuncDef> '^' <Negation>
        @Exponentiation_Caret4 = 27,               // <Exponentiation> ::= <FuncDef> '^' <FuncDef>
        @Exponentiation = 28,                      // <Exponentiation> ::= <Negation>
        @Negation_Addliteral = 29,                 // <Negation> ::= AddLiteral <Value>
        @Negation_Addliteral2 = 30,                // <Negation> ::= AddLiteral <FuncDef>
        @Negation = 31,                            // <Negation> ::= <Value>
        @Value_Id = 32,                            // <Value> ::= Id
        @Value_Number1 = 33,                       // <Value> ::= 'Number1'
        @Value_Number2 = 34,                       // <Value> ::= 'Number2'
        @Value_Lparan_Rparan = 35,                 // <Value> ::= '(' <Expression> ')'
        @Value_Pipe_Pipe = 36,                     // <Value> ::= '|' <Expression> '|'
        @Value_Lparan_Rparan_Apost = 37,           // <Value> ::= '(' <Expression> ')' ''
        @Value_Pipe_Pipe_Apost = 38,               // <Value> ::= '|' <Expression> '|' ''
        @Value_Id_Apost = 39                       // <Value> ::= Id ''
    }

    public object program;     //You might derive a specific object

    public void Setup()
    {
        //This procedure can be called to load the parse tables. The class can
        //read tables using a BinaryReader.
        
        parser.LoadTables(Application.StartupPath + "\\grammar.cgt");
    }
    
    public bool Parse(TextReader reader)
    {
        //This procedure starts the GOLD Parser Engine and handles each of the
        //messages it returns. Each time a reduction is made, you can create new
        //custom object and reassign the .CurrentReduction property. Otherwise, 
        //the system will use the Reduction object that was returned.
        //
        //The resulting tree will be a pure representation of the language 
        //and will be ready to implement.

        GOLD.ParseMessage message; 
        bool done;                      //Controls when we leave the loop
        bool accepted = false;          //Was the parse successful?

        parser.Open(reader);
        parser.TrimReductions = false;  //Please read about this feature before enabling  

        done = false;
        while (!done)
        {
            response = parser.Parse();

            switch (response)
            {
                case GOLD.ParseMessage.LexicalError:
                    //Cannot recognize token
                    done = true;
                    break;

                case GOLD.ParseMessage.SyntaxError:
                    //Expecting a different token
                    done = true;
                    break;

                case GOLD.ParseMessage.Reduction:
                    //Create a customized object to store the reduction

                    parser.CurrentReduction = CreateNewObject(parser.CurrentReduction);
                    break;

                case GOLD.ParseMessage.Accept:
                    //Accepted!
                    //program = parser.CurrentReduction   //The root node!                 
                    done = true;
                    accepted = true;
                    break;

                case GOLD.ParseMessage.TokenRead:
                    //You don't have to do anything here.
                    break;

                case GOLD.ParseMessage.InternalError:
                    //INTERNAL ERROR! Something is horribly wrong.
                    done = true;
                    break;

                case GOLD.ParseMessage.NotLoadedError:
                    //This error occurs if the CGT was not loaded.                   
                    done = true;
                    break;

                case GOLD.ParseMessage.GroupError: 
                    //GROUP ERROR! Unexpected end of file
                    done = true;
                    break;
            } 
        } //while

        return accepted;
    }
    
    private object CreateNewObject(GOLD.Reduction r)
    { 
        object result = null;
        
        switch(r.Parent.TableIndex)
        {
            case ProductionIndex.Statements:                 
                // <Statements> ::= <Statements> <Devider> <Statement>
                break;

            case ProductionIndex.Statements2:                 
                // <Statements> ::= <Statements> <Devider>
                break;

            case ProductionIndex.Statements3:                 
                // <Statements> ::= <Statement>
                break;

            case ProductionIndex.Devider_Semi:                 
                // <Devider> ::= ';'
                break;

            case ProductionIndex.Devider_Dot:                 
                // <Devider> ::= '.'
                break;

            case ProductionIndex.Statement_Eq:                 
                // <Statement> ::= <Expression> '=' <Expression>
                break;

            case ProductionIndex.Statement:                 
                // <Statement> ::= <Expression>
                break;

            case ProductionIndex.Expression:                 
                // <Expression> ::= <FuncDef>
                break;

            case ProductionIndex.Expression2:                 
                // <Expression> ::= <Addition>
                break;

            case ProductionIndex.Funcdef_Id_Lparan_Rparan:                 
                // <FuncDef> ::= Id '(' <ExpressionList> ')'
                break;

            case ProductionIndex.Funcdef_Id_Apost_Lparan_Rparan:                 
                // <FuncDef> ::= Id '' '(' <ExpressionList> ')'
                break;

            case ProductionIndex.Funcdef_Id_Lparan_Rparan_Apost:                 
                // <FuncDef> ::= Id '(' <ExpressionList> ')' ''
                break;

            case ProductionIndex.Expressionlist_Comma:                 
                // <ExpressionList> ::= <ExpressionList> ',' <Expression>
                break;

            case ProductionIndex.Expressionlist:                 
                // <ExpressionList> ::= <Expression>
                break;

            case ProductionIndex.Addition_Addliteral:                 
                // <Addition> ::= <Addition> AddLiteral <Multiplication>
                break;

            case ProductionIndex.Addition_Addliteral2:                 
                // <Addition> ::= <Addition> AddLiteral <FuncDef>
                break;

            case ProductionIndex.Addition_Addliteral3:                 
                // <Addition> ::= <FuncDef> AddLiteral <Multiplication>
                break;

            case ProductionIndex.Addition_Addliteral4:                 
                // <Addition> ::= <FuncDef> AddLiteral <FuncDef>
                break;

            case ProductionIndex.Addition:                 
                // <Addition> ::= <Multiplication>
                break;

            case ProductionIndex.Multiplication_Multliteral:                 
                // <Multiplication> ::= <Multiplication> MultLiteral <Exponentiation>
                break;

            case ProductionIndex.Multiplication_Multliteral2:                 
                // <Multiplication> ::= <Multiplication> MultLiteral <FuncDef>
                break;

            case ProductionIndex.Multiplication_Multliteral3:                 
                // <Multiplication> ::= <FuncDef> MultLiteral <Exponentiation>
                break;

            case ProductionIndex.Multiplication_Multliteral4:                 
                // <Multiplication> ::= <FuncDef> MultLiteral <FuncDef>
                break;

            case ProductionIndex.Multiplication:                 
                // <Multiplication> ::= <Exponentiation>
                break;

            case ProductionIndex.Exponentiation_Caret:                 
                // <Exponentiation> ::= <Exponentiation> '^' <Negation>
                break;

            case ProductionIndex.Exponentiation_Caret2:                 
                // <Exponentiation> ::= <Exponentiation> '^' <FuncDef>
                break;

            case ProductionIndex.Exponentiation_Caret3:                 
                // <Exponentiation> ::= <FuncDef> '^' <Negation>
                break;

            case ProductionIndex.Exponentiation_Caret4:                 
                // <Exponentiation> ::= <FuncDef> '^' <FuncDef>
                break;

            case ProductionIndex.Exponentiation:                 
                // <Exponentiation> ::= <Negation>
                break;

            case ProductionIndex.Negation_Addliteral:                 
                // <Negation> ::= AddLiteral <Value>
                break;

            case ProductionIndex.Negation_Addliteral2:                 
                // <Negation> ::= AddLiteral <FuncDef>
                break;

            case ProductionIndex.Negation:                 
                // <Negation> ::= <Value>
                break;

            case ProductionIndex.Value_Id:                 
                // <Value> ::= Id
                break;

            case ProductionIndex.Value_Number1:                 
                // <Value> ::= 'Number1'
                break;

            case ProductionIndex.Value_Number2:                 
                // <Value> ::= 'Number2'
                break;

            case ProductionIndex.Value_Lparan_Rparan:                 
                // <Value> ::= '(' <Expression> ')'
                break;

            case ProductionIndex.Value_Pipe_Pipe:                 
                // <Value> ::= '|' <Expression> '|'
                break;

            case ProductionIndex.Value_Lparan_Rparan_Apost:                 
                // <Value> ::= '(' <Expression> ')' ''
                break;

            case ProductionIndex.Value_Pipe_Pipe_Apost:                 
                // <Value> ::= '|' <Expression> '|' ''
                break;

            case ProductionIndex.Value_Id_Apost:                 
                // <Value> ::= Id ''
                break;

        }  //switch

        return result;
    }
    
}; //MyParser
